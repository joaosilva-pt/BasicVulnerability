/*
* Taken from https://blogs.msdn.microsoft.com/vcblog/2014/02/04/challenge-vulnerable-code/
*/

/***************************************************************/
/* DO NOT USE THIS CODE FOR PRODUCTION OR ANY OTHER USE        */
/* ITS MAINLY FOR TEACHING HOW TO WRITE BAD CODE - ITS TOTALLY */
/* EXPLOITABLE AND TRULY AWFUL. !!! HERE BE DRAGONS !!!        */
/***************************************************************/

#include <cstdio>
#include <windows.h>
#include <cstdlib>
#include <memory>

/******************************************************************************************/
namespace ImageFactory
{
    class Image;
    class CustomImage;

    Image* LoadFromDisk(const char* imageName);
    int GetWidth(Image *image);
    void DebugPrintDimensions(CustomImage* image);
    void DeleteImage(Image *image);
}
#define ABORT_IF(x) if(x){ std::abort(); }

/******************************************************************************************/

int main()
{
    // Load the image from disk
    ImageFactory::Image* image = ImageFactory::LoadFromDisk("Background.dat");
    ABORT_IF(image == nullptr);

    // Check the image width, if its less than 160 pixels, tell the user
    int width = ImageFactory::GetWidth(image);
    if(width < 160)
    {
        ImageFactory::DebugPrintDimensions((ImageFactory::CustomImage*)image);
        printf("Background image is too small, should be at least 160pixels\n");
    }
    else
    {
        printf("Image loaded successfully with width %d\n", width);
    }
    printf("Press enter to continue...\n");
    ImageFactory::DeleteImage(image);
    getchar();
}

/******************************************************/
/* IMAGE FACTOR FUNCTIONS FOR THE IMAGE FUNCTIONALITY */
/******************************************************/

// Base Image class
class ImageFactory::Image
{
};

// Class to represent our CustomImage type and load code
class ImageFactory::CustomImage : public Image
{
public:
    CustomImage(const char *imageName) : m_imageData(new (std::nothrow) InternalImageData())
    {
        ABORT_IF(m_imageData == nullptr);

        HANDLE h = ::CreateFileA(imageName, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_DELETE, nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);
        if(h == INVALID_HANDLE_VALUE)
        {
            DWORD lastError = ::GetLastError();
            printf("Failed to load image '%s', last error was %u", imageName, lastError);
            std::abort();
        }

        LARGE_INTEGER fileSize = {};
        BOOL success = ::GetFileSizeEx(h, &fileSize);
        ABORT_IF(!success || fileSize.HighPart != 0 || fileSize.LowPart < 3);

        // The first byte of the file is the memory type
        DWORD numBytesRead = 0;
        success = ::ReadFile(h, &m_imageData->memoryType, 1, &numBytesRead, nullptr);
        ABORT_IF(!success || numBytesRead != 1);

        // The second and subsequent bytes are actual image data.
        // Load the image data into page aligned memory with the correct characteristics (e.g. Write-Combining memory which is good for hardware access, etc)
        m_imageData->rawDataSize = fileSize.LowPart - 1;
        m_imageData->rawData = (unsigned char*)::VirtualAlloc(0, m_imageData->rawDataSize, MEM_COMMIT|MEM_RESERVE, m_imageData->memoryType);
        ABORT_IF(m_imageData->rawData == nullptr);
        numBytesRead = 0;
        success = ::ReadFile(h, m_imageData->rawData, m_imageData->rawDataSize, &numBytesRead, nullptr);
        ABORT_IF(!success || numBytesRead != m_imageData->rawDataSize);

        ::CloseHandle(h);
    }

    virtual void DebugPrintDimensions()
    {
        printf("The image is %d * %d pixels", GetWidth(), GetHeight());
    }

    // In our custom format, the first and second bytes of the raw image data are the height and width
    int GetWidth() const
    {
        return m_imageData->rawData[1];
    }
    int GetHeight() const
    {
        return m_imageData->rawData[0];
    }

    struct InternalImageData
    {
        InternalImageData() : rawData(nullptr), rawDataSize(0), memoryType(0) {}
        ~InternalImageData()
        {
            if(rawData)
            {
                ::VirtualFree(rawData, 0, MEM_FREE);
            }
        }

        unsigned char   *rawData;
        DWORD           rawDataSize;
        byte            memoryType;
    };

    std::unique_ptr<InternalImageData> m_imageData;
};

// Helper function to create a CustomImage
ImageFactory::Image* ImageFactory::LoadFromDisk(const char* imageName)
{
    return new (std::nothrow) CustomImage(imageName);
}

// Helper function to print a loaded image
void ImageFactory::DebugPrintDimensions(CustomImage* image)
{
    image->DebugPrintDimensions();
}

// Helper function to get an image's width
int ImageFactory::GetWidth(Image *image)
{
    return ((CustomImage*)image)->GetWidth();
}

void ImageFactory::DeleteImage(Image *image)
{
    delete ((CustomImage*)image);
}